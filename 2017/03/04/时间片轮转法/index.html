<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="啊，你在看我博客"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>(二)模拟时间片轮转 - Blog</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/code_fork.ico"></head><body><div class="post-header"><img class="background" src="/default_images/post_background.jpg"><div class="post-title"><h1 class="title">(二)模拟时间片轮转</h1><ul class="meta"><li><i class="icon icon-author"></i>Walden Lu</li><li><i class="icon icon-clock"></i>21 Minutes</li><li><i class="icon icon-calendar"></i>March 4, 2017</li></ul></div></div><div class="article-content" style="max-width:600px"><p>原创作品转载请注明出处</p>
<p>本篇模拟并分析了linux内核的时间片轮转法。<br><a id="more"></a></p>
<h2 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h2><p>实验环境的搭建详见<a href="https://github.com/mengning/mykernel" target="_blank" rel="external">mykernel</a><br>打上内核补丁之后，程序会从<code>__init my_start_kernel()</code>处开始启动。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h4 id="1-进程控制块-process-control-block"><a href="#1-进程控制块-process-control-block" class="headerlink" title="1.进程控制块(process control block)"></a>1.进程控制块(process control block)</h4><p>进程控制块是一个数据结构，它保存了描述一个进程所需的各种信息，例如进程的编号(pid)，进程的当前状态(status)，进程的内核栈(kernel stack)，程序计数器(PC)等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*mypcb.h*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TASK_NUM        4                   <span class="comment">//最大的任务数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_STACK_SIZE   1024*8              <span class="comment">//每个进程堆栈的大小</span></span></div><div class="line"></div><div class="line"><span class="comment">/* CPU-specific state of this task */</span></div><div class="line"><span class="keyword">struct</span> Thread &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       ip;                <span class="comment">//对应于eip</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       sp;                 <span class="comment">//对应于esp</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> PCB&#123;</div><div class="line">    <span class="keyword">int</span> pid;                     <span class="comment">//进程id</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state;    <span class="comment">/*进程状态 -1 unrunnable, 0 runnable, &gt;0 stopped */</span></div><div class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[KERNEL_STACK_SIZE];  <span class="comment">//堆栈空间</span></div><div class="line">    <span class="comment">/* CPU-specific state of this task */</span> </div><div class="line">    <span class="keyword">struct</span> Thread thread;   <span class="comment">//线程结构体</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   task_entry;   <span class="comment">//入口地址</span></div><div class="line">    <span class="keyword">struct</span> PCB *next;  <span class="comment">//下一个进程</span></div><div class="line">&#125;tPCB;</div></pre></td></tr></table></figure>
<p>以上就是结构体的定义，其中<code>Thread</code>结构体又包含：</p>
<pre><code>* ip： 表示的含义是进程下一条执行指令的地址
* sp： 表示的含义是使用进程中内核栈中的栈顶指针，初始时指向栈底 (KERNEL_STACK_SIZE-1)。
</code></pre><h4 id="2-中断"><a href="#2-中断" class="headerlink" title="2.中断"></a>2.中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*my_timer_handler()*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_timer_handler</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  </span></div><div class="line">    <span class="keyword">if</span>(time_count%<span class="number">1000</span> == <span class="number">0</span> &amp;&amp; my_need_sched != <span class="number">1</span>)  </div><div class="line">    &#123;  </div><div class="line">        printk(KERN_NOTICE <span class="string">"&gt;&gt;&gt;my_timer_handler here&lt;&lt;&lt;\n"</span>);  </div><div class="line">        my_need_sched = <span class="number">1</span>;  <span class="comment">//设置flag</span></div><div class="line">    time_count ++ ;    </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line">    <span class="keyword">return</span>;       </div><div class="line">&#125;  </div><div class="line"><span class="comment">//如果进行调度的标志位 my_need_sched 为0，则在中断处理程序中将其设置为 1，表示需要进行一次进程调度了。如果进行调度的标志位 my_need_sched 为 1，则表示正在进行调度</span></div></pre></td></tr></table></figure>
<h4 id="3-创建进程"><a href="#3-创建进程" class="headerlink" title="3.创建进程"></a>3.创建进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> tPCB task[MAX_TASK_NUM];                        <span class="comment">//进程空间   extern=声明</span></div><div class="line"><span class="keyword">extern</span> tPCB * my_current_task;                         <span class="comment">//当前进程  </span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="keyword">int</span> my_need_sched;                     <span class="comment">// volatile 易变的量 让计算机不要从缓存调用，直接去地址空间调用</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> time_count = <span class="number">0</span>;  </div><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">my_start_kernel</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> pid = <span class="number">0</span>;  <span class="comment">// 初始进程id 0  </span></div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="comment">/* Initialize process 0  */</span>  </div><div class="line">    task[pid].pid = pid;    </div><div class="line">    task[pid].state = <span class="number">0</span>;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>  </div><div class="line">    task[pid].task_entry = task[pid].thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_process;<span class="comment">//进程的入口和进程的eip都为my_process  </span></div><div class="line">    task[pid].thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;task[pid].<span class="built_in">stack</span>[KERNEL_STACK_SIZE<span class="number">-1</span>];<span class="comment">//进程的esp大小为KERNEL_STACK_SIZE，初始化esp指向它的末尾  </span></div><div class="line">    task[pid].next = &amp;task[pid]; <span class="comment">//初始化进程的下个进程为自己  </span></div><div class="line"><span class="comment">/*fork more process  */</span>   </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;MAX_TASK_NUM;i++) &#123;  </div><div class="line">          <span class="built_in">memcpy</span>(&amp;task[i],&amp;task[<span class="number">0</span>],<span class="keyword">sizeof</span>(tPCB)); <span class="comment">//进程状态简单复制  void *memcpy(void *dest, const void *src, size_t n); src源目标地址拷贝n个字节到dest目标地址</span></div><div class="line">          task[i].pid = i; <span class="comment">//进程pid  </span></div><div class="line">          task[i].state = <span class="number">-1</span>; <span class="comment">//状态为未运行   </span></div><div class="line">          task[i].thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;task[i].<span class="built_in">stack</span>[KERNEL_STACK_SIZE<span class="number">-1</span>]; <span class="comment">//堆栈地址  </span></div><div class="line">          task[i].next = task[i<span class="number">-1</span>].next; <span class="comment">//进程链  </span></div><div class="line">          task[i<span class="number">-1</span>].next = &amp;task[i]; <span class="comment">//这里是一个循环单链表   </span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//........</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://olxo556gm.bkt.clouddn.com/%E5%8D%95%E9%93%BE%E8%A1%A8.png?imageMogr2/thumbnail/640x/format/webp/blur/1x0/quality/75|watermark/2/text/c3NzY29yY2g=/font/5a6L5L2T/fontsize/240/fill/IzAwMDAwMA==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="样式"></p>
<p><strong>以上完成了初始化部分，我们确定好了数据结构，初始化了4个进程控制块，下面就开始启动我们的进程了</strong></p>
<h4 id="4-启动进程"><a href="#4-启动进程" class="headerlink" title="4.启动进程"></a>4.启动进程</h4><p>以下代码嵌入了汇编，请参考<a href="https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/" target="_blank" rel="external">linux中的内联汇编</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pid = 0; my_current_task = &amp;task[pid]; //汇编运行0号进程  </div><div class="line">      asm volatile(  //volatile表示不要优化</div><div class="line">                "movl %1,%%esp\n\t" /* 为什么先设置esp???set task[pid].thread.sp to esp 使用进程的堆地址，即esp指向进程的堆空间*/   </div><div class="line">                "pushl %1\n\t" /* push ebp 这里为什么是push ebp不懂了，理论上是压入了esp的地址（老师解释这里是由于栈是空的ebp等于esp）*/   </div><div class="line">                "pushl %0\n\t" /* push task[pid].thread.ip，压入eip地址，等待运行 */   </div><div class="line">               "ret\n\t" /* pop task[pid].thread.ip to eip，因为eip的值程序员是不能修改的，只能采用这总雅展再ret的方式。回顾上一周的课程可知，这里是把eip的地址指向了task[pid].thread.ip(已经被我们设置程了my_process的入口地址)的地址了,并popl了一次*/   </div><div class="line">                "popl %%ebp\n\t" /*弹出ebp，整个进程空间释放了*/     </div><div class="line">                 :  //输出部分</div><div class="line">         : "c" (task[pid].thread.ip),"d" (task[pid].thread.sp) /* input c or d mean %ecx/%edx*/);  //输入部分</div></pre></td></tr></table></figure>
<h4 id="5-进入主函数my-process"><a href="#5-进入主函数my-process" class="headerlink" title="5.进入主函数my_process()"></a>5.进入主函数my_process()</h4><p>当4中的代码运行到<code>&quot;ret\n\t&quot;</code>这一句时，内核根据eip所指向的地址寻找要运行的指令，即进入了函数my_process()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面是进程工作的代码，代码很简单就是 每10000000 来运行一次，相隔着来进行进程的调度切换，至于是否调度切换是有标志my_need_sched 来决定的。  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_process</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </div><div class="line">    &#123;  </div><div class="line">        i++;  </div><div class="line">        <span class="keyword">if</span>(i%<span class="number">10000000</span> == <span class="number">0</span>)  </div><div class="line">        &#123;  </div><div class="line">            printk(KERN_NOTICE <span class="string">"this is process %d -\n"</span>,my_current_task-&gt;pid);  </div><div class="line">            <span class="keyword">if</span>(my_need_sched == <span class="number">1</span>)  </div><div class="line">            &#123;  </div><div class="line">                my_need_sched = <span class="number">0</span>;  </div><div class="line">                my_schedule();  </div><div class="line">            &#125;  </div><div class="line">            printk(KERN_NOTICE <span class="string">"this is process %d +\n"</span>,my_current_task-&gt;pid);  </div><div class="line">        &#125;       </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-调度函数"><a href="#6-调度函数" class="headerlink" title="6.调度函数"></a>6.调度函数</h4><p>my_schedule() 函数的主要功能就是切换进程执行，而进程间切换主要需要完成的工作就是保存进程的上下文环境，换句话说，就是先保存上一个进程的执行时相关寄存器的状态（例如 ebp,esp,eip等寄存器中内容），以便进程切换回来时能够从上一次执行的位置继续往下执行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">void my_schedule(void)</div><div class="line">&#123;</div><div class="line">    tPCB *next; // 下一个需要调度的进程</div><div class="line">    tPCB *prev; // 调度前执行的进程</div><div class="line">    if (my_current_task == NULL || my_current_task-&gt;next == NULL)</div><div class="line">    &#123;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    printk(KERN_NOTICE "&gt;&gt;&gt; my_schedule &lt;&lt;&lt;\n");</div><div class="line">    next = my_current_task-&gt;next;</div><div class="line">    prev = my_current_task;</div><div class="line">    if (next-&gt;state == 0)</div><div class="line">    &#123;</div><div class="line">        my_current_task = next;</div><div class="line">        printk(KERN_NOTICE "&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\n", prev-&gt;pid, next-&gt;pid);</div><div class="line">        /* switch to next process */</div><div class="line">        asm volatile (</div><div class="line">            "pushl %%ebp\n\t"  // 保存 prev 进程的栈底指针地址，并将其压入到 prev 栈中</div><div class="line">            "movl %%esp, %0\n\t"   // 将 prev 进程中 栈顶指针 esp 保存到 prev 进程控制块中 thread.sp 数据成员中</div><div class="line">            "movl %2, %%esp\n\t"   // 将 next 指向进程中的栈底指针保存到 esp 中</div><div class="line">            "movl $1f,%1\n\t"      // 将 prev 指向进程下一条要执行的指令保存到进程控制块中</div><div class="line">            "pushl %3\n\t"         // 将 next 指向进程的下一条指令入栈</div><div class="line">            "ret\n\t"              // 将 next 进程需要执行的下一条指令弹出到 eip 寄存器中</div><div class="line">            "1: \t"</div><div class="line">            "popl %%ebp\n\t" // 弹出 next 进程栈订顶的值到 ebp 寄存器中</div><div class="line">            : "=m"(prev-&gt;thread.sp), "=m"(prev-&gt;thread.ip)</div><div class="line">            : "m"(next-&gt;thread.sp), "m"(next-&gt;thread.ip)</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        next-&gt;state = 0;</div><div class="line">        my_current_task = next;</div><div class="line">        printk(KERN_NOTICE "&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\n", prev-&gt;pid, next-&gt;pid);</div><div class="line">        /* switch to new process */</div><div class="line">        asm volatile (</div><div class="line">            "pushl %%ebp\n\t" // 将 prev 进程中栈的栈底指针保存到 prev 栈中</div><div class="line">            "movl %%esp,%0\n\t" // 将 prev 进程中 栈顶指针 esp 保存到 prev 进程控制块中 thread.sp 数据成员中</div><div class="line">            "movl %2,%%ebp\n\t" // 将 next 进程的栈底地址送到 ebp 寄存器中</div><div class="line">            "movl %2,%%esp\n\t" // 将 next 进程的栈顶地址送到 esp 寄存器中</div><div class="line">            "movl $1f,%1\n\t"   // 保存 prev 指向进程下一次执行时的指令地址，也就是标号为 1 处的地址</div><div class="line">            "pushl %3\n\t" // 将 next 进程的入口地址压入到栈中</div><div class="line">            "ret\n\t" // 将 next 进程的下一条执行的指令弹出，然后从刚弹出的指令地址开始执行</div><div class="line">            : "=m"(prev-&gt;thread.sp), "=m"(prev-&gt;thread.ip)</div><div class="line">            : "m"(next-&gt;thread.sp), "m"(next-&gt;thread.ip)</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们就详细来分析下这个函数的实现：</p>
<ul>
<li><p>step 1：首先函数中先定义了两个进程控制块的指针next 和 prev ，分别用来指向下一个轮转到的进程，以及轮转前执行的进程。</p>
</li>
<li><p>step 2：接下来，我们就得对分两种情况进行讨论了，第一种情况是进程链表中下一个轮转到的进程还从未运行过，第二种情况是下一个轮转到的集成已经在运行了。这两种情况的主要区别就在于第一种情况中在内联汇编代码中需要首先初始化进程中的栈，第二种情况中每个进程的栈都已经初始化好了，只需要简单地切换栈即可。</p>
</li>
<li><p>step 3: 有关两种情况所执行的内联汇编代码的含义，我都在上面的代码中给出了详细的注释。</p>
</li>
</ul>
<p>运行结果</p>
<p><img src="http://olxo556gm.bkt.clouddn.com/%E7%BB%93%E6%9E%9C.PNG?imageMogr2/thumbnail/640x/format/webp/blur/1x0/quality/75|watermark/2/text/c3NzY29yY2g=/font/5a6L5L2T/fontsize/240/fill/IzAwMDAwMA==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p>
</div><div class="article-meta" style="max-width:600px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux内核/">linux内核</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时间片轮转/">时间片轮转</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核分析/">linux内核分析</a><span class="category-list-count">2</span></li></ul></div></div><div class="article-comment" style="max-width:600px"><div class="ds-thread" id="ds-thread" data-thread-key="cizwf8gsp0004q8vz9bcsvjww" data-title="(二)模拟时间片轮转" data-url="http://yoursite.com/2017/03/04/时间片轮转法/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/03/05/Java中的对象及其引用/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/02/25/计算机是如何工作的/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/WaldenLu" title="GitHub" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="972672562@qq.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 Blog</p></div></div></body></html>